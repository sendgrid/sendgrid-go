/*
* This code was generated by
*
* SENDGRID-OAI-GENERATOR
*
* Twilio SendGrid Subusers
* The Twilio SendGrid Subusers API allows you to create and manage your Subuser accounts. Subusers are available on [Pro and Premier plans](https://sendgrid.com/pricing), and you can think of them as sub-accounts. Each Subuser can have its own sending domains, IP addresses, and reporting. SendGrid recommends creating Subusers for each of the different types of emails you sendâ€”one Subuser for transactional emails and another for marketing emails. Independent Software Vendor (ISV) customers may also create Subusers for each of their customers.  You can also manage Subusers in the [Twilio SendGrid application user interface](https://app.sendgrid.com/settings/subusers). See [**Subusers**](https://docs.sendgrid.com/ui/account-and-settings/subusers) for more information.
*
* NOTE: This class is auto generated by OpenAPI Generator.
* https://openapi-generator.tech
* Do not edit the class manually.
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
)

type ListSubuserParam struct {
	// The username of this subuser.
	Username *string `json:"username,omitempty"`
	// `limit` sets the page size, i.e. maximum number of items from the list to be returned for a single API request. If omitted, the default page size is used.
	Limit *int32 `json:"limit,omitempty"`
	// Filter for Subusers in this region. If not provided, all Subusers will be returned. All users can also be explicitly requested by using the filter `all`. Users who are not pinned to a region will be displayed as `global`.
	Region *Region `json:"region,omitempty"`
	// Optional flag to include the regions of the Subusers in the response. If not provided, the region will be omitted from the response.
	IncludeRegion *bool `json:"include_region,omitempty"`
	// The number of items in the list to skip over before starting to retrieve the items for the requested page. The default `offset` of `0` represents the beginning of the list, i.e. the start of the first page. To request the second page of the list, set the `offset` to the page size as determined by `limit`. Use multiples of the page size as your `offset` to request further consecutive pages. E.g. assume your page size is set to `10`. An `offset` of `10` requests the second page, an `offset` of `20` requests the third page and so on, provided there are sufficiently many items in your list.
	Offset *int32 `json:"offset,omitempty"`
}

func (params *ListSubuserParam) SetUsername(Username string) *ListSubuserParam {
	params.Username = &Username
	return params
}
func (params *ListSubuserParam) SetLimit(Limit int32) *ListSubuserParam {
	params.Limit = &Limit
	return params
}
func (params *ListSubuserParam) SetRegion(Region Region) *ListSubuserParam {
	params.Region = &Region
	return params
}
func (params *ListSubuserParam) SetIncludeRegion(IncludeRegion bool) *ListSubuserParam {
	params.IncludeRegion = &IncludeRegion
	return params
}
func (params *ListSubuserParam) SetOffset(Offset int32) *ListSubuserParam {
	params.Offset = &Offset
	return params
}

// **This endpoint allows you to retrieve a paginated list of all your subusers.**  You can use the `username` query parameter to filter the list for specific subusers.  You can use the `limit` query parameter to set the page size. If your list contains more items than the page size permits, you can make multiple requests. Use the `offset` query parameter to control the position in the list from which to start retrieving additional items.
func (c *ApiService) ListSubuser(params *ListSubuserParam) (interface{}, error) {
	path := "/v3/subusers"

	data := url.Values{}
	headers := map[string]interface{}{
		"Content-Type": "application/x-www-form-urlencoded",
	}

	if params != nil && params.Username != nil {
		data.Set("username", *params.Username)
	}
	if params != nil && params.Limit != nil {
		data.Set("limit", fmt.Sprint(*params.Limit))
	}
	if params != nil && params.Region != nil {
		data.Set("region", fmt.Sprint(*params.Region))
	}
	if params != nil && params.IncludeRegion != nil {
		data.Set("include_region", fmt.Sprint(*params.IncludeRegion))
	}
	if params != nil && params.Offset != nil {
		data.Set("offset", fmt.Sprint(*params.Offset))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		ps := &[]Subuser{}
		if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
			return nil, err
		}

		return ps, err
	}
	if resp.StatusCode == 401 {
		ps := &ErrorResponse{}
		if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
			return nil, err
		}

		return ps, err
	}
	return http.Response{StatusCode: resp.StatusCode, Body: resp.Body, Header: resp.Header}, nil
}
