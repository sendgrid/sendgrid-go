/*
* This code was generated by
*
* SENDGRID-OAI-GENERATOR
*
* Twilio SendGrid Webhook Configuration API
* The Twilio SendGrid Webhooks API allows you to configure the Event and Parse Webhooks.  Email is a data-rich channel, and implementing the Event Webhook will allow you to consume those data in nearly real time. This means you can actively monitor and participate in the health of your email program throughout the send cycle.  The Inbound Parse Webhook processes all incoming email for a domain or subdomain, parses the contents and attachments and then POSTs `multipart/form-data` to a URL that you choose.
*
* NOTE: This class is auto generated by OpenAPI Generator.
* https://openapi-generator.tech
* Do not edit the class manually.
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
)

type ListParseStaticParam struct {
	// The starting date of the statistics you want to retrieve. Must be in the format YYYY-MM-DD
	StartDate *string `json:"start_date"`
	// The number of statistics to return on each page.
	Limit *string `json:"limit,omitempty"`
	// The number of statistics to skip.
	Offset *string `json:"offset,omitempty"`
	// How you would like the statistics to by grouped.
	AggregatedBy *AggregatedBy `json:"aggregated_by,omitempty"`
	// The end date of the statistics you want to retrieve. Must be in the format YYYY-MM-DD
	EndDate *string `json:"end_date,omitempty"`
	// The `on-behalf-of` header allows you to make API calls from a parent account on behalf of the parent's Subusers or customer accounts. You will use the parent account's API key when using this header. When making a call on behalf of a customer account, the property value should be \"account-id\" followed by the customer account's ID (e.g., `on-behalf-of: account-id <account-id>`). When making a call on behalf of a Subuser, the property value should be the Subuser's username (e.g., `on-behalf-of: <subuser-username>`). See [**On Behalf Of**](https://docs.sendgrid.com/api-reference/how-to-use-the-sendgrid-v3-api/on-behalf-of) for more information.
	Onbehalfof *string `json:"on-behalf-of,omitempty"`
}

func (params *ListParseStaticParam) SetStartDate(StartDate string) *ListParseStaticParam {
	params.StartDate = &StartDate
	return params
}
func (params *ListParseStaticParam) SetLimit(Limit string) *ListParseStaticParam {
	params.Limit = &Limit
	return params
}
func (params *ListParseStaticParam) SetOffset(Offset string) *ListParseStaticParam {
	params.Offset = &Offset
	return params
}
func (params *ListParseStaticParam) SetAggregatedBy(AggregatedBy AggregatedBy) *ListParseStaticParam {
	params.AggregatedBy = &AggregatedBy
	return params
}
func (params *ListParseStaticParam) SetEndDate(EndDate string) *ListParseStaticParam {
	params.EndDate = &EndDate
	return params
}
func (params *ListParseStaticParam) SetOnbehalfof(Onbehalfof string) *ListParseStaticParam {
	params.Onbehalfof = &Onbehalfof
	return params
}

// **This endpoint allows you to retrieve the statistics for your Parse Webhook usage.**  SendGrid's Inbound Parse Webhook allows you to parse the contents and attachments of incoming emails. The Parse API can then POST the parsed emails to a URL that you specify. The Inbound Parse Webhook cannot parse messages greater than 30MB in size, including all attachments.  There are a number of pre-made integrations for the SendGrid Parse Webhook which make processing events easy. You can find these integrations in the [Library Index](https://docs.sendgrid.com/for-developers/sending-email/libraries#webhook-libraries).
func (c *ApiService) ListParseStatic(params *ListParseStaticParam) (interface{}, error) {
	path := "/v3/user/webhooks/parse/stats"

	data := url.Values{}
	headers := map[string]interface{}{
		"Content-Type": "application/x-www-form-urlencoded",
	}

	if params != nil && params.StartDate != nil {
		data.Set("start_date", *params.StartDate)
	}
	if params != nil && params.Limit != nil {
		data.Set("limit", *params.Limit)
	}
	if params != nil && params.Offset != nil {
		data.Set("offset", *params.Offset)
	}
	if params != nil && params.AggregatedBy != nil {
		data.Set("aggregated_by", fmt.Sprint(*params.AggregatedBy))
	}
	if params != nil && params.EndDate != nil {
		data.Set("end_date", *params.EndDate)
	}

	if params != nil && params.Onbehalfof != nil {
		headers["on-behalf-of"] = *params.Onbehalfof
	}
	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		ps := &[]ListParseStatic200ResponseInner{}
		if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
			return nil, err
		}

		return ps, err
	}
	return http.Response{Status: resp.Status, StatusCode: resp.StatusCode, Body: resp.Body}, nil
}
