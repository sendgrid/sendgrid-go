/*
* This code was generated by
*
* SENDGRID-OAI-GENERATOR
*
* Twilio SendGrid IP Address API
* The Twilio SendGrid IP Address API allows you to add and manage dedicated IP addresses and IP Pools for your SendGrid account and Subusers. If you are sending any significant amount of email, SendGrid typically suggests sending from dedicated IPs. It's also best to send marketing and transactional emails from separate IP addresses. In order to do this, you'll need to set up IP Pools, which are groups of dedicated IP addresses you define to send particular types of messages. See the [**Dedicated IP Addresses**](https://docs.sendgrid.com/ui/account-and-settings/dedicated-ip-addresses) for more information about obtaining and allocating IPs.
*
* NOTE: This class is auto generated by OpenAPI Generator.
* https://openapi-generator.tech
* Do not edit the class manually.
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"
)

type ListIpParam struct {
	// The IP address to get
	Ip *string `json:"ip,omitempty"`
	// Should we exclude reverse DNS records (whitelabels)?
	ExcludeWhitelabels *bool `json:"exclude_whitelabels,omitempty"`
	// `limit` sets the page size, i.e. maximum number of items from the list to be returned for a single API request. If omitted, the default page size is used.
	Limit *int32 `json:"limit,omitempty"`
	// The number of items in the list to skip over before starting to retrieve the items for the requested page. The default `offset` of `0` represents the beginning of the list, i.e. the start of the first page. To request the second page of the list, set the `offset` to the page size as determined by `limit`. Use multiples of the page size as your `offset` to request further consecutive pages. E.g. assume your page size is set to `10`. An `offset` of `10` requests the second page, an `offset` of `20` requests the third page and so on, provided there are sufficiently many items in your list.
	Offset *int32 `json:"offset,omitempty"`
	// The subuser you are requesting for.
	Subuser *string `json:"subuser,omitempty"`
	// The direction to sort the results.
	SortByDirection *SortByDirection `json:"sort_by_direction,omitempty"`
}

func (params *ListIpParam) SetIp(Ip string) *ListIpParam {
	params.Ip = &Ip
	return params
}
func (params *ListIpParam) SetExcludeWhitelabels(ExcludeWhitelabels bool) *ListIpParam {
	params.ExcludeWhitelabels = &ExcludeWhitelabels
	return params
}
func (params *ListIpParam) SetLimit(Limit int32) *ListIpParam {
	params.Limit = &Limit
	return params
}
func (params *ListIpParam) SetOffset(Offset int32) *ListIpParam {
	params.Offset = &Offset
	return params
}
func (params *ListIpParam) SetSubuser(Subuser string) *ListIpParam {
	params.Subuser = &Subuser
	return params
}
func (params *ListIpParam) SetSortByDirection(SortByDirection SortByDirection) *ListIpParam {
	params.SortByDirection = &SortByDirection
	return params
}

// **This endpoint allows you to retrieve a paginated list of all assigned and unassigned IPs.**  Response includes warm up status, pools, assigned subusers, and reverse DNS info. The start_date field corresponds to when warmup started for that IP.  A single IP address or a range of IP addresses may be dedicated to an account in order to send email for multiple domains. The reputation of this IP is determined by the aggregate performance of all email traffic sent from it.  You can use the `limit` query parameter to set the page size. If your list contains more items than the page size permits, you can make multiple requests. Use the `offset` query parameter to control the position in the list from which to start retrieving additional items.
func (c *ApiService) ListIp(params *ListIpParam) (interface{}, error) {
	path := "/v3/ips"

	data := url.Values{}
	headers := map[string]interface{}{
		"Content-Type": "application/x-www-form-urlencoded",
	}

	if params != nil && params.Ip != nil {
		data.Set("ip", *params.Ip)
	}
	if params != nil && params.ExcludeWhitelabels != nil {
		data.Set("exclude_whitelabels", fmt.Sprint(*params.ExcludeWhitelabels))
	}
	if params != nil && params.Limit != nil {
		data.Set("limit", fmt.Sprint(*params.Limit))
	}
	if params != nil && params.Offset != nil {
		data.Set("offset", fmt.Sprint(*params.Offset))
	}
	if params != nil && params.Subuser != nil {
		data.Set("subuser", *params.Subuser)
	}
	if params != nil && params.SortByDirection != nil {
		data.Set("sort_by_direction", fmt.Sprint(*params.SortByDirection))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		ps := &[]ListIp200ResponseInner{}
		if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
			return nil, err
		}

		return ps, err
	}
	return nil, nil
}
